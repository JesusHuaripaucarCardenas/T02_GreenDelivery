```sql 
CREATE TABLE role (
    id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name VARCHAR2(50) NOT NULL,
    description VARCHAR2(250),
    status CHAR(1) DEFAULT 'A' NOT NULL,
    creation_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL
);
COMMIT;

ALTER TABLE role ADD CONSTRAINT uk_role_name UNIQUE (name);
COMMIT;

ALTER TABLE role ADD CONSTRAINT ck_role_status CHECK (status IN ('A','I'));
COMMIT;

ALTER TABLE role ADD CONSTRAINT ck_role_name_length CHECK (LENGTH(name) >= 3);
COMMIT;

CREATE TABLE users (
    id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    email VARCHAR2(150) NOT NULL,
    password VARCHAR2(250) NOT NULL,
    role_id NUMBER NOT NULL,
    name VARCHAR2(100) NOT NULL,
    last_name VARCHAR2(100) NOT NULL,
    birthdate DATE,
    phone VARCHAR2(15),
    sex VARCHAR2(10),
    document_type CHAR(3) DEFAULT 'DNI' NOT NULL,
    document_number VARCHAR2(20),
    creation_register TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL,
    alternative_phone VARCHAR2(15),
    company_name VARCHAR2(50),
    license VARCHAR2(20),
    hire_date DATE,
    average_grade NUMBER(3,2) DEFAULT 0.00,
    total_deliveries NUMBER DEFAULT 0,
    status CHAR(1) DEFAULT 'A' NOT NULL
);
COMMIT;

ALTER TABLE users ADD CONSTRAINT uk_users_email UNIQUE (email);
COMMIT;

ALTER TABLE users ADD CONSTRAINT uk_users_document UNIQUE (document_type, document_number);
COMMIT;

ALTER TABLE users ADD CONSTRAINT uk_users_license UNIQUE (license);
COMMIT;

ALTER TABLE users ADD CONSTRAINT ck_users_email CHECK (email LIKE '%@%');
COMMIT;

ALTER TABLE users ADD CONSTRAINT ck_users_status CHECK (status IN ('A','I','S'));
COMMIT;

ALTER TABLE users ADD CONSTRAINT ck_users_sex CHECK (sex IN ('masculino', 'femenino', 'otro'));
COMMIT;

ALTER TABLE users ADD CONSTRAINT ck_users_document_type CHECK (document_type IN ('DNI', 'RUC', 'CNE'));
COMMIT;

ALTER TABLE users ADD CONSTRAINT ck_users_grade CHECK (average_grade BETWEEN 0.00 AND 5.00);
COMMIT;

ALTER TABLE users ADD CONSTRAINT ck_users_deliveries CHECK (total_deliveries >= 0);
COMMIT;

ALTER TABLE users ADD CONSTRAINT ck_users_phone CHECK (REGEXP_LIKE(phone, '^[0-9+\-\s()]+$'));
COMMIT;

ALTER TABLE users ADD CONSTRAINT ck_users_driver_fields CHECK (
    (role_id != 3) OR
    (role_id = 3 AND document_number IS NOT NULL AND license IS NOT NULL AND hire_date IS NOT NULL)
);
COMMIT;

CREATE INDEX idx_users_role ON users(role_id);
COMMIT;

CREATE INDEX idx_users_status ON users(status);
COMMIT;

CREATE INDEX idx_users_document_number ON users(document_number);
COMMIT;

CREATE INDEX idx_users_creation_date ON users(creation_register);
COMMIT;

CREATE TABLE orders (
    id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    users_id NUMBER NOT NULL,
    order_code VARCHAR2(20) NOT NULL,
    order_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL,
    requested_delivery_date DATE,
    priority CHAR(1) DEFAULT 'N' NOT NULL,
    subtotal NUMBER(10,2) DEFAULT 0.00,
    shipping_cost NUMBER(8,2) DEFAULT 0.00,
    total NUMBER(10,2) DEFAULT 0.00,
    status CHAR(1) DEFAULT 'R' NOT NULL
);
COMMIT;

ALTER TABLE orders ADD CONSTRAINT uk_orders_code UNIQUE (order_code);
COMMIT;

ALTER TABLE orders ADD CONSTRAINT ck_orders_priority CHECK (priority IN ('B','N','A','U'));
COMMIT;

ALTER TABLE orders ADD CONSTRAINT ck_orders_status CHECK (status IN ('R','C','P','T','E','X'));
COMMIT;

ALTER TABLE orders ADD CONSTRAINT ck_orders_amounts CHECK (subtotal >= 0 AND shipping_cost >= 0 AND total >= 0);
COMMIT;

ALTER TABLE orders ADD CONSTRAINT ck_orders_total CHECK (total = subtotal + shipping_cost);
COMMIT;

ALTER TABLE orders ADD CONSTRAINT ck_orders_delivery_date CHECK (requested_delivery_date >= TRUNC(order_date));
COMMIT;

ALTER TABLE orders ADD CONSTRAINT ck_orders_code_format CHECK (REGEXP_LIKE(order_code, '^[A-Z0-9\-]+$'));
COMMIT;

CREATE INDEX idx_orders_client ON orders(users_id);
COMMIT;

CREATE INDEX idx_orders_status ON orders(status);
COMMIT;

CREATE INDEX idx_orders_date ON orders(order_date);
COMMIT;

CREATE INDEX idx_orders_priority ON orders(priority);
COMMIT;

CREATE TABLE order_details (
    id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    orders_id NUMBER NOT NULL,
    quantity NUMBER DEFAULT 1 NOT NULL,
    unit_price NUMBER(10,2)
);
COMMIT;

ALTER TABLE order_details ADD CONSTRAINT ck_order_details_quantity CHECK (quantity > 0);
COMMIT;

ALTER TABLE order_details ADD CONSTRAINT ck_order_details_price CHECK (unit_price >= 0 OR unit_price IS NULL);
COMMIT;

CREATE TABLE product (
    id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    orders_id NUMBER NOT NULL,
    code VARCHAR2(20) NOT NULL,
    name VARCHAR2(30) NOT NULL,
    description VARCHAR2(100),
    unit_weight NUMBER(6,3),
    fragile CHAR(1) DEFAULT 'N' NOT NULL,
    cooled CHAR(1) DEFAULT 'N' NOT NULL,
    reference_price NUMBER(10,2),
    date_register TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL,
    status CHAR(1) DEFAULT 'A' NOT NULL
);
COMMIT;

ALTER TABLE product ADD CONSTRAINT uk_product_code UNIQUE (code);
COMMIT;

ALTER TABLE product ADD CONSTRAINT ck_product_fragile CHECK (fragile IN ('S','N'));
COMMIT;

ALTER TABLE product ADD CONSTRAINT ck_product_cooled CHECK (cooled IN ('S','N'));
COMMIT;

ALTER TABLE product ADD CONSTRAINT ck_product_status CHECK (status IN ('A','I'));
COMMIT;

ALTER TABLE product ADD CONSTRAINT ck_product_weight CHECK (unit_weight > 0 OR unit_weight IS NULL);
COMMIT;

ALTER TABLE product ADD CONSTRAINT ck_product_price CHECK (reference_price >= 0 OR reference_price IS NULL);
COMMIT;

ALTER TABLE product ADD CONSTRAINT ck_product_name_length CHECK (LENGTH(name) >= 2);
COMMIT;

CREATE TABLE address (
    id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    street VARCHAR2(200) NOT NULL,
    "number" VARCHAR2(10),
    district VARCHAR2(100) NOT NULL,
    postal_code NUMBER,
    reference VARCHAR2(250),
    latitude NUMBER(10,8),
    length NUMBER(11,8),
    creation_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL,
    orders_id NUMBER NOT NULL
);
COMMIT;

ALTER TABLE address ADD CONSTRAINT uk_address_location UNIQUE (street, "number", district);
COMMIT;

ALTER TABLE address ADD CONSTRAINT ck_address_latitude CHECK (latitude BETWEEN -90 AND 90 OR latitude IS NULL);
COMMIT;

ALTER TABLE address ADD CONSTRAINT ck_address_longitude CHECK (length BETWEEN -180 AND 180 OR length IS NULL);
COMMIT;

ALTER TABLE address ADD CONSTRAINT ck_address_postal_code CHECK (postal_code > 0 OR postal_code IS NULL);
COMMIT;

ALTER TABLE address ADD CONSTRAINT ck_address_street_length CHECK (LENGTH(street) >= 5);
COMMIT;

CREATE INDEX idx_address_district ON address(district);
COMMIT;

CREATE INDEX idx_address_postal_code ON address(postal_code);
COMMIT;

CREATE TABLE user_addresses (
    id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    users_id NUMBER NOT NULL,
    address_id NUMBER NOT NULL,
    alias VARCHAR2(20),
    is_main CHAR(1) DEFAULT 'N' NOT NULL,
    status CHAR(1) DEFAULT 'A' NOT NULL,
    date_register TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL
);
COMMIT;

ALTER TABLE user_addresses ADD CONSTRAINT uk_user_addresses UNIQUE (users_id, address_id);
COMMIT;

ALTER TABLE user_addresses ADD CONSTRAINT ck_user_addresses_is_main CHECK (is_main IN ('S','N'));
COMMIT;

ALTER TABLE user_addresses ADD CONSTRAINT ck_user_addresses_status CHECK (status IN ('A','I'));
COMMIT;

CREATE TABLE status_tracking (
    id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    orders_id NUMBER NOT NULL,
    previous_status VARCHAR2(20),
    new_status VARCHAR2(20) NOT NULL,
    "comment" VARCHAR2(200),
    "user" VARCHAR2(100),
    change_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL
);
COMMIT;

ALTER TABLE status_tracking ADD CONSTRAINT ck_st_statuses_different CHECK (previous_status != new_status OR previous_status IS NULL);
COMMIT;

CREATE TABLE deliveries (
    id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    orders_id NUMBER NOT NULL,
    departure_time TIMESTAMP,
    delivery_time TIMESTAMP,
    delivery_cost NUMBER(8,2),
    distance_traveled NUMBER(6,2),
    status CHAR(1) DEFAULT 'A' NOT NULL
);
COMMIT;

ALTER TABLE deliveries ADD CONSTRAINT ck_deliveries_status CHECK (status IN ('A','R','T','E','F','P'));
COMMIT;

ALTER TABLE deliveries ADD CONSTRAINT ck_deliveries_cost CHECK (delivery_cost >= 0 OR delivery_cost IS NULL);
COMMIT;

ALTER TABLE deliveries ADD CONSTRAINT ck_deliveries_distance CHECK (distance_traveled >= 0 OR distance_traveled IS NULL);
COMMIT;

ALTER TABLE deliveries ADD CONSTRAINT ck_deliveries_times CHECK (delivery_time >= departure_time OR delivery_time IS NULL OR departure_time IS NULL);
COMMIT;

CREATE TABLE vehicle (
    id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    plate VARCHAR2(10) NOT NULL,
    vehicle_type VARCHAR2(20) NOT NULL,
    brand VARCHAR2(50),
    model VARCHAR2(50),
    year NUMBER(4),
    load_capacity NUMBER(7,2) DEFAULT 0,
    last_revision_date DATE,
    next_review DATE,
    maturity_insurance DATE,
    observation VARCHAR2(300),
    creation_register DATE DEFAULT SYSDATE NOT NULL,
    status CHAR(1) DEFAULT 'A' NOT NULL
);
COMMIT;

ALTER TABLE vehicle ADD CONSTRAINT uk_vehicle_plate UNIQUE (plate);
COMMIT;

ALTER TABLE vehicle ADD CONSTRAINT ck_vehicle_status CHECK (status IN ('A','I','M','F'));
COMMIT;

ALTER TABLE vehicle ADD CONSTRAINT ck_vehicle_capacity CHECK (load_capacity >= 0);
COMMIT;

ALTER TABLE vehicle ADD CONSTRAINT ck_vehicle_plate_format CHECK (REGEXP_LIKE(plate, '^[A-Z0-9\-]+$'));
COMMIT;

ALTER TABLE vehicle ADD CONSTRAINT ck_vehicle_revision_dates CHECK (next_review > last_revision_date OR next_review IS NULL OR last_revision_date IS NULL);
COMMIT;

CREATE INDEX idx_vehicle_type ON vehicle(vehicle_type);
COMMIT;

CREATE INDEX idx_vehicle_status ON vehicle(status);
COMMIT;

CREATE INDEX idx_vehicle_next_review ON vehicle(next_review);
COMMIT;

CREATE TABLE vehicle_driver (
    id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    driver_id NUMBER NOT NULL,
    vehicle_id NUMBER NOT NULL,
    assignment_date DATE NOT NULL,
    deallocation_date DATE,
    is_main CHAR(1) DEFAULT 'N' NOT NULL,
    status CHAR(1) DEFAULT 'A' NOT NULL,
    observation VARCHAR2(250),
    creation_register DATE DEFAULT SYSDATE NOT NULL
);
COMMIT;

ALTER TABLE vehicle_driver ADD CONSTRAINT uk_vehicle_driver_assignment UNIQUE (driver_id, vehicle_id, assignment_date);
COMMIT;

ALTER TABLE vehicle_driver ADD CONSTRAINT ck_vehicle_driver_is_main CHECK (is_main IN ('S','N'));
COMMIT;

ALTER TABLE vehicle_driver ADD CONSTRAINT ck_vehicle_driver_status CHECK (status IN ('A','I'));
COMMIT;

ALTER TABLE vehicle_driver ADD CONSTRAINT ck_vehicle_driver_dates CHECK (deallocation_date >= assignment_date OR deallocation_date IS NULL);
COMMIT;

CREATE INDEX idx_vehicle_driver_driver ON vehicle_driver(driver_id);
COMMIT;

CREATE INDEX idx_vehicle_driver_vehicle ON vehicle_driver(vehicle_id);
COMMIT;

CREATE INDEX idx_vehicle_driver_date ON vehicle_driver(assignment_date);
COMMIT;

CREATE TABLE routes (
    id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name VARCHAR2(150) NOT NULL,
    description VARCHAR2(250),
    main_district VARCHAR2(100) NOT NULL,
    distance_km NUMBER(6,2),
    estimated_time_minutes NUMBER,
    difficulty VARCHAR2(15) DEFAULT 'medio' NOT NULL,
    status CHAR(1) DEFAULT 'A' NOT NULL,
    date_register TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL
);
COMMIT;

ALTER TABLE routes ADD CONSTRAINT ck_routes_difficulty CHECK (difficulty IN ('facil', 'medio', 'dificil'));
COMMIT;

ALTER TABLE routes ADD CONSTRAINT ck_routes_status CHECK (status IN ('A','I'));
COMMIT;

ALTER TABLE routes ADD CONSTRAINT ck_routes_distance CHECK (distance_km > 0 OR distance_km IS NULL);
COMMIT;

ALTER TABLE routes ADD CONSTRAINT ck_routes_time CHECK (estimated_time_minutes > 0 OR estimated_time_minutes IS NULL);
COMMIT;

ALTER TABLE routes ADD CONSTRAINT ck_routes_name_length CHECK (LENGTH(name) >= 5);
COMMIT;

CREATE TABLE routes_points (
    id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    routes_id NUMBER NOT NULL,
    "order" NUMBER NOT NULL,
    name VARCHAR2(50),
    description VARCHAR2(250),
    latitude NUMBER(10,8),
    length NUMBER(11,8),
    point_type VARCHAR2(20) DEFAULT 'intermedio' NOT NULL,
    estimated_time_minutes NUMBER,
    distance_meters NUMBER,
    observation VARCHAR2(250),
    status CHAR(1) DEFAULT 'A' NOT NULL,
    date_register TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL
);
COMMIT;

ALTER TABLE routes_points ADD CONSTRAINT uk_routes_points_order UNIQUE (routes_id, "order");
COMMIT;

ALTER TABLE routes_points ADD CONSTRAINT ck_routes_points_type CHECK (point_type IN ('inicio', 'intermedio', 'destino', 'referencia'));
COMMIT;

ALTER TABLE routes_points ADD CONSTRAINT ck_routes_points_status CHECK (status IN ('A','I'));
COMMIT;

ALTER TABLE routes_points ADD CONSTRAINT ck_routes_points_order_positive CHECK ("order" > 0);
COMMIT;

ALTER TABLE routes_points ADD CONSTRAINT ck_routes_points_latitude CHECK (latitude BETWEEN -90 AND 90 OR latitude IS NULL);
COMMIT;

ALTER TABLE routes_points ADD CONSTRAINT ck_routes_points_longitude CHECK (length BETWEEN -180 AND 180 OR length IS NULL);
COMMIT;

ALTER TABLE routes_points ADD CONSTRAINT ck_routes_points_time CHECK (estimated_time_minutes >= 0 OR estimated_time_minutes IS NULL);
COMMIT;

ALTER TABLE routes_points ADD CONSTRAINT ck_routes_points_distance CHECK (distance_meters >= 0 OR distance_meters IS NULL);
COMMIT;

CREATE TABLE route_segments (
    id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    routes_id NUMBER NOT NULL,
    origin_point NUMBER NOT NULL,
    destination_point NUMBER NOT NULL,
    order_segment NUMBER NOT NULL,
    instruction VARCHAR2(250),
    address VARCHAR2(20),
    street_name VARCHAR2(50),
    distance_meters NUMBER,
    estimated_time_minutes NUMBER,
    average_speed NUMBER(4,1),
    difficulty VARCHAR2(15) DEFAULT 'medio' NOT NULL,
    via_type VARCHAR2(20) DEFAULT 'calle' NOT NULL,
    trafficlight CHAR(1) DEFAULT 'N' NOT NULL,
    toll CHAR(1) DEFAULT 'N' NOT NULL,
    earring VARCHAR2(20) DEFAULT 'plano' NOT NULL,
    regular_traffic VARCHAR2(20) DEFAULT 'medio' NOT NULL,
    date_register TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL
);
COMMIT;

ALTER TABLE route_segments ADD CONSTRAINT ck_route_segments_address CHECK (address IN ('recto', 'derecha', 'izquierda', 'retorno', 'rotonda'));
COMMIT;

ALTER TABLE route_segments ADD CONSTRAINT ck_route_segments_difficulty CHECK (difficulty IN ('facil', 'medio', 'dificil'));
COMMIT;

ALTER TABLE route_segments ADD CONSTRAINT ck_route_segments_via_type CHECK (via_type IN ('avenida', 'calle', 'jiron', 'autopista', 'ciclovia'));
COMMIT;

ALTER TABLE route_segments ADD CONSTRAINT ck_route_segments_trafficlight CHECK (trafficlight IN ('S','N'));
COMMIT;

ALTER TABLE route_segments ADD CONSTRAINT ck_route_segments_toll CHECK (toll IN ('S','N'));
COMMIT;

ALTER TABLE route_segments ADD CONSTRAINT ck_route_segments_earring CHECK (earring IN ('plano', 'subida', 'bajada'));
COMMIT;

ALTER TABLE route_segments ADD CONSTRAINT ck_route_segments_traffic CHECK (regular_traffic IN ('bajo', 'medio', 'alto'));
COMMIT;

ALTER TABLE route_segments ADD CONSTRAINT ck_route_segments_points CHECK (origin_point != destination_point);
COMMIT;

ALTER TABLE route_segments ADD CONSTRAINT ck_route_segments_order CHECK (order_segment > 0);
COMMIT;

ALTER TABLE route_segments ADD CONSTRAINT ck_route_segments_distance CHECK (distance_meters >= 0 OR distance_meters IS NULL);
COMMIT;

ALTER TABLE route_segments ADD CONSTRAINT ck_route_segments_time CHECK (estimated_time_minutes >= 0 OR estimated_time_minutes IS NULL);
COMMIT;

ALTER TABLE route_segments ADD CONSTRAINT ck_route_segments_speed CHECK (average_speed > 0 OR average_speed IS NULL);
COMMIT;

CREATE TABLE origin_destination_routes (
    id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    source_address NUMBER NOT NULL,
    destination_address NUMBER NOT NULL,
    main_path NUMBER NOT NULL,
    alternative_route NUMBER,
    distance_km NUMBER(6,2),
    average_time_minutes NUMBER,
    times_used NUMBER DEFAULT 0,
    average_rating NUMBER(3,2) DEFAULT 0,
    status CHAR(1) DEFAULT 'A' NOT NULL,
    date_register TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL
);
COMMIT;

ALTER TABLE origin_destination_routes ADD CONSTRAINT uk_odr_addresses UNIQUE (source_address, destination_address);
COMMIT;

ALTER TABLE origin_destination_routes ADD CONSTRAINT ck_odr_status CHECK (status IN ('A','I'));
COMMIT;

ALTER TABLE origin_destination_routes ADD CONSTRAINT ck_odr_addresses_different CHECK (source_address != destination_address);
COMMIT;

ALTER TABLE origin_destination_routes ADD CONSTRAINT ck_odr_routes_different CHECK (main_path != alternative_route OR alternative_route IS NULL);
COMMIT;

ALTER TABLE origin_destination_routes ADD CONSTRAINT ck_odr_distance CHECK (distance_km > 0 OR distance_km IS NULL);
COMMIT;

ALTER TABLE origin_destination_routes ADD CONSTRAINT ck_odr_time CHECK (average_time_minutes > 0 OR average_time_minutes IS NULL);
COMMIT;

ALTER TABLE origin_destination_routes ADD CONSTRAINT ck_odr_times_used CHECK (times_used >= 0);
COMMIT;

ALTER TABLE origin_destination_routes ADD CONSTRAINT ck_odr_rating CHECK (average_rating BETWEEN 0 AND 5 OR average_rating IS NULL);
COMMIT;

CREATE TABLE driver_favorite_routes (
    id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    driver_id NUMBER NOT NULL,
    routes_id NUMBER NOT NULL,
    times_used NUMBER DEFAULT 1,
    average_time_minutes NUMBER,
    average_rating NUMBER(3,2),
    personal_notes VARCHAR2(250),
    first_date_ DATE,
    last_date DATE,
    status CHAR(1) DEFAULT 'A' NOT NULL
);
COMMIT;

ALTER TABLE driver_favorite_routes ADD CONSTRAINT uk_dfr_driver_route UNIQUE (driver_id, routes_id);
COMMIT;

ALTER TABLE driver_favorite_routes ADD CONSTRAINT ck_dfr_status CHECK (status IN ('A','I'));
COMMIT;

ALTER TABLE driver_favorite_routes ADD CONSTRAINT ck_dfr_times_used CHECK (times_used > 0);
COMMIT;

ALTER TABLE driver_favorite_routes ADD CONSTRAINT ck_dfr_time CHECK (average_time_minutes > 0 OR average_time_minutes IS NULL);
COMMIT;

ALTER TABLE driver_favorite_routes ADD CONSTRAINT ck_dfr_rating CHECK (average_rating BETWEEN 0 AND 5 OR average_rating IS NULL);
COMMIT;

ALTER TABLE driver_favorite_routes ADD CONSTRAINT ck_dfr_dates CHECK (last_date >= first_date_ OR last_date IS NULL OR first_date_ IS NULL);
COMMIT;

CREATE TABLE driver_assignments (
    id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    driver_id NUMBER NOT NULL,
    routes_id NUMBER NOT NULL,
    assignment_date DATE NOT NULL,
    start_time DATE,
    end_time DATE,
    status VARCHAR2(15) DEFAULT 'programada' NOT NULL,
    observation VARCHAR2(150),
    date_register TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL
);
COMMIT;

ALTER TABLE driver_assignments ADD CONSTRAINT uk_da_driver_date UNIQUE (driver_id, assignment_date);
COMMIT;

ALTER TABLE driver_assignments ADD CONSTRAINT ck_da_status CHECK (status IN ('programada', 'en_curso', 'completada', 'cancelada'));
COMMIT;

ALTER TABLE driver_assignments ADD CONSTRAINT ck_da_times CHECK (end_time >= start_time OR end_time IS NULL OR start_time IS NULL);
COMMIT;

CREATE TABLE delivery_routes (
    id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    deliveries_id NUMBER NOT NULL,
    routes_id NUMBER NOT NULL,
    usage_type CHAR(1) DEFAULT 'P' NOT NULL,
    deviations NUMBER DEFAULT 0,
    actual_time_minutes NUMBER,
    actual_distance_km NUMBER(6,2),
    route_rating NUMBER(1),
    remarks VARCHAR2(200),
    usage_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL
);
COMMIT;

ALTER TABLE delivery_routes ADD CONSTRAINT ck_dr_usage_type CHECK (usage_type IN ('P','E','A'));
COMMIT;

ALTER TABLE delivery_routes ADD CONSTRAINT ck_dr_deviations CHECK (deviations >= 0);
COMMIT;

ALTER TABLE delivery_routes ADD CONSTRAINT ck_dr_time CHECK (actual_time_minutes > 0 OR actual_time_minutes IS NULL);
COMMIT;

ALTER TABLE delivery_routes ADD CONSTRAINT ck_dr_distance CHECK (actual_distance_km >= 0 OR actual_distance_km IS NULL);
COMMIT;

ALTER TABLE delivery_routes ADD CONSTRAINT ck_dr_rating CHECK (route_rating BETWEEN 1 AND 5 OR route_rating IS NULL);
COMMIT;

ALTER TABLE users ADD CONSTRAINT fk_users_role FOREIGN KEY (role_id) REFERENCES role(id);
COMMIT;

ALTER TABLE orders ADD CONSTRAINT fk_orders_users FOREIGN KEY (users_id) REFERENCES users(id);
COMMIT;

ALTER TABLE order_details ADD CONSTRAINT fk_order_details_orders FOREIGN KEY (orders_id) REFERENCES orders(id) ON DELETE CASCADE;
COMMIT;

ALTER TABLE product ADD CONSTRAINT fk_product_orders FOREIGN KEY (orders_id) REFERENCES orders(id);
COMMIT;

ALTER TABLE address ADD CONSTRAINT fk_address_orders FOREIGN KEY (orders_id) REFERENCES orders(id);
COMMIT;

ALTER TABLE user_addresses ADD CONSTRAINT fk_user_addresses_users FOREIGN KEY (users_id) REFERENCES users(id) ON DELETE CASCADE;
COMMIT;

ALTER TABLE user_addresses ADD CONSTRAINT fk_user_addresses_address FOREIGN KEY (address_id) REFERENCES address(id);
COMMIT;

ALTER TABLE status_tracking ADD CONSTRAINT fk_st_orders FOREIGN KEY (orders_id) REFERENCES orders(id) ON DELETE CASCADE;
COMMIT;

ALTER TABLE deliveries ADD CONSTRAINT fk_deliveries_orders FOREIGN KEY (orders_id) REFERENCES orders(id);
COMMIT;

ALTER TABLE vehicle_driver ADD CONSTRAINT fk_vehicle_driver_user FOREIGN KEY (driver_id) REFERENCES users(id);
COMMIT;

ALTER TABLE vehicle_driver ADD CONSTRAINT fk_vehicle_driver_vehicle FOREIGN KEY (vehicle_id) REFERENCES vehicle(id);
COMMIT;

ALTER TABLE routes_points ADD CONSTRAINT fk_routes_points_routes FOREIGN KEY (routes_id) REFERENCES routes(id) ON DELETE CASCADE;
COMMIT;

ALTER TABLE route_segments ADD CONSTRAINT fk_route_segments_routes FOREIGN KEY (routes_id) REFERENCES routes(id) ON DELETE CASCADE;
COMMIT;

ALTER TABLE route_segments ADD CONSTRAINT fk_route_segments_origin FOREIGN KEY (origin_point) REFERENCES routes_points(id);
COMMIT;

ALTER TABLE route_segments ADD CONSTRAINT fk_route_segments_destination FOREIGN KEY (destination_point) REFERENCES routes_points(id);
COMMIT;

ALTER TABLE origin_destination_routes ADD CONSTRAINT fk_odr_source FOREIGN KEY (source_address) REFERENCES user_addresses(id);
COMMIT;

ALTER TABLE origin_destination_routes ADD CONSTRAINT fk_odr_destination FOREIGN KEY (destination_address) REFERENCES user_addresses(id);
COMMIT;

ALTER TABLE origin_destination_routes ADD CONSTRAINT fk_odr_main_path FOREIGN KEY (main_path) REFERENCES routes(id);
COMMIT;

ALTER TABLE origin_destination_routes ADD CONSTRAINT fk_odr_alternative FOREIGN KEY (alternative_route) REFERENCES routes(id);
COMMIT;

ALTER TABLE driver_favorite_routes ADD CONSTRAINT fk_dfr_driver FOREIGN KEY (driver_id) REFERENCES users(id);
COMMIT;

ALTER TABLE driver_favorite_routes ADD CONSTRAINT fk_dfr_routes FOREIGN KEY (routes_id) REFERENCES routes(id);
COMMIT;

ALTER TABLE driver_assignments ADD CONSTRAINT fk_da_driver FOREIGN KEY (driver_id) REFERENCES users(id);
COMMIT;

ALTER TABLE driver_assignments ADD CONSTRAINT fk_da_routes FOREIGN KEY (routes_id) REFERENCES routes(id);
COMMIT;

ALTER TABLE delivery_routes ADD CONSTRAINT fk_dr_deliveries FOREIGN KEY (deliveries_id) REFERENCES deliveries(id);
COMMIT;

ALTER TABLE delivery_routes ADD CONSTRAINT fk_dr_routes FOREIGN KEY (routes_id) REFERENCES routes(id);
COMMIT;

CREATE OR REPLACE TRIGGER tr_unique_main_address
    BEFORE INSERT OR UPDATE ON user_addresses
    FOR EACH ROW
    WHEN (NEW.is_main = 'S')
BEGIN
    UPDATE user_addresses
    SET is_main = 'N'
    WHERE users_id = :NEW.users_id
    AND is_main = 'S'
    AND id != NVL(:NEW.id, -1);
END tr_unique_main_address;
/
COMMIT;

CREATE OR REPLACE TRIGGER tr_unique_main_vehicle
    BEFORE INSERT OR UPDATE ON vehicle_driver
    FOR EACH ROW
    WHEN (NEW.is_main = 'S')
BEGIN
    UPDATE vehicle_driver
    SET is_main = 'N'
    WHERE driver_id = :NEW.driver_id
    AND is_main = 'S'
    AND status = 'A'
    AND id != NVL(:NEW.id, -1);
END tr_unique_main_vehicle;
/
COMMIT;

CREATE OR REPLACE TRIGGER tr_update_route_totals
FOR INSERT OR UPDATE OR DELETE ON routes_points
COMPOUND TRIGGER

  TYPE t_set IS TABLE OF BOOLEAN INDEX BY PLS_INTEGER;
  g_route_set t_set;

  PROCEDURE add_id(p_id NUMBER) IS
    k PLS_INTEGER;
  BEGIN
    IF p_id IS NOT NULL THEN
      k := TRUNC(p_id);
      g_route_set(k) := TRUE;
    END IF;
  END;

  AFTER EACH ROW IS
  BEGIN
    IF INSERTING OR UPDATING THEN
      add_id(:NEW.routes_id);
    ELSE
      add_id(:OLD.routes_id);
    END IF;
  END AFTER EACH ROW;

  AFTER STATEMENT IS
    k PLS_INTEGER;
  BEGIN
    k := g_route_set.FIRST;
    WHILE k IS NOT NULL LOOP
      UPDATE routes r
         SET r.distance_km = (
               SELECT CASE
                        WHEN SUM(distance_meters) > 0
                          THEN SUM(distance_meters) / 1000
                        ELSE NULL
                      END
               FROM   routes_points
               WHERE  routes_id = k
               AND    status = 'A'
             ),
             r.estimated_time_minutes = (
               SELECT CASE
                        WHEN SUM(estimated_time_minutes) > 0
                          THEN SUM(estimated_time_minutes)
                        ELSE NULL
                      END
               FROM   routes_points
               WHERE  routes_id = k
               AND    status = 'A'
             )
       WHERE r.id = k;

      k := g_route_set.NEXT(k);
    END LOOP;
  END AFTER STATEMENT;

END tr_update_route_totals;
/
COMMIT;

CREATE OR REPLACE TRIGGER tr_update_route_stats
FOR INSERT OR UPDATE OF usage_type, actual_time_minutes, route_rating, deliveries_id, routes_id
ON delivery_routes
COMPOUND TRIGGER

  TYPE t_set IS TABLE OF PLS_INTEGER INDEX BY PLS_INTEGER;
  g_routes     t_set;
  g_deliveries t_set;

  PROCEDURE add_route(p_id NUMBER) IS k PLS_INTEGER; BEGIN
    IF p_id IS NOT NULL THEN k := TRUNC(p_id); g_routes(k) := 1; END IF;
  END;
  PROCEDURE add_delivery(p_id NUMBER) IS k PLS_INTEGER; BEGIN
    IF p_id IS NOT NULL THEN k := TRUNC(p_id); g_deliveries(k) := 1; END IF;
  END;

  AFTER EACH ROW IS
  BEGIN
    IF INSERTING OR UPDATING THEN
      IF :NEW.usage_type = 'E' OR :OLD.usage_type = 'E' THEN
        add_route(:NEW.routes_id);
        add_delivery(:NEW.deliveries_id);
      END IF;
    END IF;
  END AFTER EACH ROW;

  AFTER STATEMENT IS
    k PLS_INTEGER;
  BEGIN
    k := g_routes.FIRST;
    WHILE k IS NOT NULL LOOP
      UPDATE origin_destination_routes odr
         SET times_used = NVL( (SELECT COUNT(*)
                                FROM delivery_routes dr
                                WHERE dr.routes_id = k AND dr.usage_type = 'E'), 0),
             average_time_minutes = (SELECT NVL(AVG(dr.actual_time_minutes), 0)
                                     FROM delivery_routes dr
                                     WHERE dr.routes_id = k
                                       AND dr.usage_type = 'E'
                                       AND dr.actual_time_minutes IS NOT NULL),
             average_rating = (SELECT NVL(AVG(dr.route_rating), 0)
                               FROM delivery_routes dr
                               WHERE dr.routes_id = k
                                 AND dr.usage_type = 'E'
                                 AND dr.route_rating IS NOT NULL)
       WHERE odr.main_path = k;
      k := g_routes.NEXT(k);
    END LOOP;

    k := g_deliveries.FIRST;
    WHILE k IS NOT NULL LOOP
      DECLARE
        v_route_id  NUMBER;
        v_time      NUMBER;
        v_rating    NUMBER;
        v_driver_id NUMBER;
        v_cnt       NUMBER;
      BEGIN
        SELECT dr.routes_id, dr.actual_time_minutes, dr.route_rating
          INTO v_route_id, v_time, v_rating
          FROM delivery_routes dr
         WHERE dr.deliveries_id = k
           AND dr.usage_type = 'E'
           AND ROWNUM = 1;

        SELECT da.driver_id
          INTO v_driver_id
          FROM driver_assignments da
          JOIN deliveries d ON d.id = k
         WHERE da.routes_id = v_route_id
           AND da.assignment_date <= TRUNC(NVL(d.delivery_time, SYSDATE))
           AND da.status IN ('programada','en_curso','completada')
           AND ROWNUM = 1;

        SELECT COUNT(*) INTO v_cnt
          FROM driver_favorite_routes
         WHERE driver_id = v_driver_id
           AND routes_id  = v_route_id;

        IF v_cnt > 0 THEN
          UPDATE driver_favorite_routes
             SET times_used = times_used + 1,
                 last_date = TRUNC(SYSDATE),
                 average_time_minutes = NVL(v_time, average_time_minutes),
                 average_rating       = NVL(v_rating, average_rating)
           WHERE driver_id = v_driver_id
             AND routes_id  = v_route_id;
        ELSE
          INSERT INTO driver_favorite_routes
            (driver_id, routes_id, times_used, first_date_, last_date,
             average_time_minutes, average_rating)
          VALUES
            (v_driver_id, v_route_id, 1, TRUNC(SYSDATE), TRUNC(SYSDATE),
             v_time, v_rating);
        END IF;

      EXCEPTION
        WHEN NO_DATA_FOUND THEN NULL;
        WHEN OTHERS THEN NULL;
      END;

      k := g_deliveries.NEXT(k);
    END LOOP;
  END AFTER STATEMENT;

END tr_update_route_stats;
/
COMMIT;

CREATE OR REPLACE TRIGGER tr_update_driver_stats
    AFTER UPDATE ON deliveries
    FOR EACH ROW
    WHEN (NEW.status = 'E' AND OLD.status != 'E')
DECLARE
    v_driver_id NUMBER;
    v_avg_rating NUMBER;
BEGIN
    SELECT da.driver_id INTO v_driver_id
    FROM driver_assignments da
    JOIN delivery_routes dr ON da.routes_id = dr.routes_id
    WHERE dr.deliveries_id = :NEW.id
    AND da.status = 'completada'
    AND ROWNUM = 1;

    SELECT NVL(AVG(dr.route_rating), 0) INTO v_avg_rating
    FROM delivery_routes dr
    JOIN deliveries d ON dr.deliveries_id = d.id
    JOIN driver_assignments da ON da.routes_id = dr.routes_id
    WHERE da.driver_id = v_driver_id
    AND d.status = 'E'
    AND dr.route_rating IS NOT NULL;

    UPDATE users
    SET total_deliveries = total_deliveries + 1,
        average_grade = v_avg_rating
    WHERE id = v_driver_id;

EXCEPTION
    WHEN NO_DATA_FOUND THEN
        NULL;
    WHEN OTHERS THEN
        NULL;
END tr_update_driver_stats;
/
COMMIT;

CREATE OR REPLACE TRIGGER tr_update_order_status
    AFTER UPDATE ON deliveries
    FOR EACH ROW
    WHEN (NEW.status = 'E' AND OLD.status != 'E')
BEGIN
    UPDATE orders
    SET status = 'E'
    WHERE id = :NEW.orders_id;

    INSERT INTO status_tracking (orders_id, previous_status, new_status, "comment", "user")
    VALUES (:NEW.orders_id, 'T', 'E', 'Entrega completada automáticamente', 'SYSTEM');

EXCEPTION
    WHEN OTHERS THEN
        NULL;
END tr_update_order_status;
/
COMMIT;

CREATE OR REPLACE TRIGGER tr_calculate_order_total
FOR INSERT OR UPDATE OR DELETE ON order_details
COMPOUND TRIGGER

  TYPE t_set IS TABLE OF BOOLEAN INDEX BY PLS_INTEGER;
  g_order_set t_set;

  PROCEDURE add_id(p_id NUMBER) IS
    k PLS_INTEGER;
  BEGIN
    IF p_id IS NOT NULL THEN
      k := TRUNC(p_id);
      g_order_set(k) := TRUE;
    END IF;
  END;

  AFTER EACH ROW IS
  BEGIN
    IF INSERTING OR UPDATING THEN
      add_id(:NEW.orders_id);
    ELSE
      add_id(:OLD.orders_id);
    END IF;
  END AFTER EACH ROW;

  AFTER STATEMENT IS
    k PLS_INTEGER;
    v_subtotal NUMBER;
  BEGIN
    k := g_order_set.FIRST;
    WHILE k IS NOT NULL LOOP
      SELECT NVL(SUM(quantity * NVL(unit_price, 0)), 0)
        INTO v_subtotal
        FROM order_details
       WHERE orders_id = k;

      UPDATE orders
         SET subtotal = v_subtotal,
             total    = v_subtotal + shipping_cost
       WHERE id = k;

      k := g_order_set.NEXT(k);
    END LOOP;
  END AFTER STATEMENT;

END tr_calculate_order_total;
/
COMMIT;

CREATE OR REPLACE TRIGGER tr_track_order_status_changes
    AFTER UPDATE ON orders
    FOR EACH ROW
    WHEN (OLD.status != NEW.status)
BEGIN
    INSERT INTO status_tracking (orders_id, previous_status, new_status, "comment", "user")
    VALUES (:NEW.id, :OLD.status, :NEW.status, 'Cambio automático de estado', 'SYSTEM');
EXCEPTION
    WHEN OTHERS THEN
        NULL;
END tr_track_order_status_changes;
/
COMMIT;

CREATE OR REPLACE VIEW vista_users_complete AS
SELECT
    u.id,
    u.name || ' ' || u.last_name AS full_name,
    u.email,
    u.phone,
    u.sex,
    u.document_type,
    u.document_number,
    r.name AS role_name,
    r.description AS role_description,
    CASE u.status
        WHEN 'A' THEN 'Activo'
        WHEN 'I' THEN 'Inactivo'
        WHEN 'S' THEN 'Suspendido'
    END AS status_description,
    u.creation_register,
    u.company_name,
    u.license,
    u.total_deliveries,
    u.average_grade,
    u.hire_date
FROM users u
JOIN role r ON u.role_id = r.id;
COMMIT;

CREATE OR REPLACE VIEW vista_vehicle_drivers AS
SELECT
    v.id,
    v.plate,
    v.vehicle_type,
    v.brand,
    v.model,
    CASE v.status
        WHEN 'A' THEN 'Activo'
        WHEN 'I' THEN 'Inactivo'
        WHEN 'M' THEN 'Mantenimiento'
        WHEN 'F' THEN 'Fuera de servicio'
    END AS status_description,
    v.load_capacity,
    u.name || ' ' || u.last_name AS assigned_driver,
    u.email AS driver_email,
    CASE vd.is_main WHEN 'S' THEN 'Principal' ELSE 'Secundario' END AS vehicle_priority,
    vd.assignment_date,
    CASE vd.status WHEN 'A' THEN 'Activo' ELSE 'Inactivo' END AS assignment_status
FROM vehicle v
LEFT JOIN vehicle_driver vd ON v.id = vd.vehicle_id AND vd.status = 'A'
LEFT JOIN users u ON vd.driver_id = u.id;
COMMIT;

CREATE OR REPLACE VIEW vista_route_complete AS
SELECT
    r.id AS route_id,
    r.name AS route_name,
    r.description AS route_description,
    r.main_district,
    r.distance_km,
    r.estimated_time_minutes,
    rp.id AS point_id,
    rp."order" AS point_order,
    rp.name AS point_name,
    rp.description AS point_description,
    rp.point_type,
    rp.latitude,
    rp.length,
    rp.estimated_time_minutes AS point_time,
    rp.distance_meters
FROM routes r
JOIN routes_points rp ON r.id = rp.routes_id
WHERE r.status = 'A' AND rp.status = 'A'
ORDER BY r.id, rp."order";
COMMIT;

CREATE OR REPLACE VIEW vista_orders_complete AS
SELECT
    o.id,
    o.order_code,
    u.name || ' ' || u.last_name AS client_name,
    u.email AS client_email,
    u.phone AS client_phone,
    u.company_name,
    a.street || ' ' || NVL(a."number", '') || ', ' || a.district AS delivery_address,
    a.reference AS delivery_reference,
    o.order_date,
    o.requested_delivery_date,
    CASE o.status
        WHEN 'R' THEN 'Recibido'
        WHEN 'C' THEN 'Confirmado'
        WHEN 'P' THEN 'Preparando'
        WHEN 'T' THEN 'En Tránsito'
        WHEN 'E' THEN 'Entregado'
        WHEN 'X' THEN 'Cancelado'
    END AS status_description,
    CASE o.priority
        WHEN 'B' THEN 'Baja'
        WHEN 'N' THEN 'Normal'
        WHEN 'A' THEN 'Alta'
        WHEN 'U' THEN 'Urgente'
    END AS priority_description,
    o.subtotal,
    o.shipping_cost,
    o.total,
    d.delivery_time,
    CASE d.status
        WHEN 'A' THEN 'Asignada'
        WHEN 'R' THEN 'Recogida'
        WHEN 'T' THEN 'En Tránsito'
        WHEN 'E' THEN 'Entregada'
        WHEN 'F' THEN 'Fallida'
        WHEN 'P' THEN 'Reprogramada'
    END AS delivery_status
FROM orders o
JOIN users u ON o.users_id = u.id
LEFT JOIN address a ON o.id = a.orders_id
LEFT JOIN deliveries d ON o.id = d.orders_id;
COMMIT;

CREATE OR REPLACE VIEW vista_popular_routes AS
SELECT
    r.id AS route_id,
    r.name AS route_name,
    r.description,
    r.main_district,
    r.distance_km,
    r.estimated_time_minutes,
    COUNT(dr.id) as total_deliveries,
    NVL(AVG(dr.actual_time_minutes), 0) as average_real_time,
    NVL(AVG(dr.route_rating), 0) as average_rating,
    COUNT(DISTINCT da.driver_id) as different_drivers,
    MAX(dr.usage_date) as last_used
FROM routes r
LEFT JOIN delivery_routes dr ON r.id = dr.routes_id AND dr.usage_type = 'E'
LEFT JOIN deliveries d ON dr.deliveries_id = d.id
LEFT JOIN driver_assignments da ON da.routes_id = r.id
WHERE r.status = 'A'
GROUP BY r.id, r.name, r.description, r.main_district, r.distance_km, r.estimated_time_minutes
ORDER BY total_deliveries DESC;
COMMIT;

CREATE OR REPLACE VIEW vista_driver_stats AS
SELECT
    u.id AS driver_id,
    u.name || ' ' || u.last_name AS driver_name,
    u.email,
    u.license,
    u.hire_date,
    u.total_deliveries,
    u.average_grade,
    CASE u.status
        WHEN 'A' THEN 'Activo'
        WHEN 'I' THEN 'Inactivo'
        WHEN 'S' THEN 'Suspendido'
    END AS status_description,
    v.plate AS assigned_vehicle,
    v.vehicle_type,
    COUNT(da.id) AS total_assignments,
    COUNT(CASE WHEN da.status = 'completada' THEN 1 END) AS completed_assignments
FROM users u
LEFT JOIN vehicle_driver vd ON u.id = vd.driver_id AND vd.status = 'A' AND vd.is_main = 'S'
LEFT JOIN vehicle v ON vd.vehicle_id = v.id
LEFT JOIN driver_assignments da ON u.id = da.driver_id
WHERE u.role_id = 3
GROUP BY u.id, u.name, u.last_name, u.email, u.license, u.hire_date,
         u.total_deliveries, u.average_grade, u.status, v.plate, v.vehicle_type
ORDER BY u.total_deliveries DESC;
COMMIT;

CREATE OR REPLACE PROCEDURE sp_assign_driver_to_route(
    p_driver_id        IN NUMBER,
    p_route_id         IN NUMBER,
    p_assignment_date  IN DATE DEFAULT SYSDATE,
    p_start_time       IN DATE DEFAULT NULL,
    p_end_time         IN DATE DEFAULT NULL,
    p_observation      IN VARCHAR2 DEFAULT NULL
) AS
BEGIN
    INSERT INTO driver_assignments (
        driver_id, routes_id, assignment_date, start_time, end_time, status, observation
    ) VALUES (
        p_driver_id, p_route_id, p_assignment_date, p_start_time, p_end_time, 'programada', p_observation
    );

    COMMIT;
EXCEPTION
    WHEN DUP_VAL_ON_INDEX THEN
        RAISE_APPLICATION_ERROR(-20001, 'El conductor ya tiene una asignación para esa fecha');
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE;
END sp_assign_driver_to_route;
/
COMMIT;

CREATE OR REPLACE PROCEDURE sp_complete_delivery(
    p_delivery_id IN NUMBER,
    p_actual_time IN NUMBER DEFAULT NULL,
    p_actual_distance IN NUMBER DEFAULT NULL,
    p_route_rating IN NUMBER DEFAULT NULL,
    p_remarks IN VARCHAR2 DEFAULT NULL
) AS
BEGIN
    UPDATE deliveries
    SET status = 'E',
        delivery_time = CURRENT_TIMESTAMP
    WHERE id = p_delivery_id;

    UPDATE delivery_routes
    SET usage_type = 'E',
        actual_time_minutes = p_actual_time,
        actual_distance_km = p_actual_distance,
        route_rating = p_route_rating,
        remarks = p_remarks
    WHERE deliveries_id = p_delivery_id;

    COMMIT;
EXCEPTION
    WHEN NO_DATA_FOUND THEN
        RAISE_APPLICATION_ERROR(-20002, 'Entrega no encontrada');
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE;
END sp_complete_delivery;
/
COMMIT;

CREATE OR REPLACE FUNCTION fn_get_best_available_driver(
    p_date IN DATE DEFAULT SYSDATE
) RETURN NUMBER AS
    v_driver_id NUMBER;
BEGIN
    SELECT u.id INTO v_driver_id
    FROM users u
    WHERE u.role_id = 3
    AND u.status = 'A'
    AND NOT EXISTS (
        SELECT 1 FROM driver_assignments da
        WHERE da.driver_id = u.id
        AND da.assignment_date = TRUNC(p_date)
        AND da.status IN ('programada', 'en_curso')
    )
    ORDER BY u.average_grade DESC, u.total_deliveries DESC
    FETCH FIRST 1 ROWS ONLY;

    RETURN v_driver_id;
EXCEPTION
    WHEN NO_DATA_FOUND THEN
        RETURN NULL;
    WHEN OTHERS THEN
        RETURN NULL;
END fn_get_best_available_driver;
/
COMMIT;

CREATE INDEX idx_orders_requested_date ON orders(requested_delivery_date);
COMMIT;

CREATE INDEX idx_deliveries_departure_time ON deliveries(departure_time);
COMMIT;

CREATE INDEX idx_delivery_routes_usage_date ON delivery_routes(usage_date);
COMMIT;

CREATE INDEX idx_driver_assignments_status ON driver_assignments(status);
COMMIT;

CREATE INDEX idx_status_tracking_change_date ON status_tracking(change_date);
COMMIT;

INSERT INTO role (name, description)
VALUES ('Administrador', 'Usuario con permisos completos del sistema');
COMMIT;

INSERT INTO role (name, description)
VALUES ('Cliente', 'Usuario que realiza pedidos');
COMMIT;

INSERT INTO role (name, description, status)
VALUES ('Conductor', 'Usuario encargado de las entregas', 'A');
COMMIT;

UPDATE role
SET description = 'Usuario que gestiona y administra el sistema completo'
WHERE name = 'Administrador';
COMMIT;

INSERT INTO users (email, password, role_id, name, last_name, birthdate, phone, sex, document_type, document_number)
VALUES ('admin@delivery.com', '$2a$10$hash1', 1, 'Carlos', 'Rodriguez', DATE '1985-03-15', '987654321', 'masculino', 'DNI', '12345678');
COMMIT;

INSERT INTO users (email, password, role_id, name, last_name, birthdate, phone, sex, document_type, document_number, alternative_phone, company_name)
VALUES ('cliente1@email.com', '$2a$10$hash2', 2, 'Maria', 'Gonzalez', DATE '1990-07-22', '976543210', 'femenino', 'DNI', '87654321', '965432109', 'Empresa ABC');
COMMIT;

INSERT INTO users (email, password, role_id, name, last_name, birthdate, phone, sex, document_type, document_number, license, hire_date)
VALUES ('conductor1@delivery.com', '$2a$10$hash3', 3, 'Juan', 'Perez', DATE '1988-12-10', '954321098', 'masculino', 'DNI', '11223344', 'LIC123456', DATE '2024-01-15');
COMMIT;

UPDATE users
SET phone = '987654322', alternative_phone = '965432108'
WHERE email = 'cliente1@email.com';
COMMIT;

INSERT INTO orders (users_id, order_code, requested_delivery_date, priority, subtotal, shipping_cost, total)
VALUES (2, 'ORD-2025-001', DATE '2025-08-18', 'N', 150.50, 15.00, 165.50);
COMMIT;

INSERT INTO orders (users_id, order_code, requested_delivery_date, priority, subtotal, shipping_cost, total, status)
VALUES (2, 'ORD-2025-002', DATE '2025-08-19', 'A', 89.75, 12.50, 102.25, 'C');
COMMIT;

INSERT INTO orders (users_id, order_code, requested_delivery_date, priority, subtotal, shipping_cost, total, status)
VALUES (2, 'ORD-2025-003', DATE '2025-08-20', 'U', 245.00, 25.00, 270.00, 'P');
COMMIT;

UPDATE orders
SET status = 'C', subtotal = 155.75, total = 170.75
WHERE order_code = 'ORD-2025-001';
COMMIT;

INSERT INTO order_details (orders_id, quantity, unit_price)
VALUES (1, 2, 75.25);
COMMIT;

INSERT INTO order_details (orders_id, quantity, unit_price)
VALUES (2, 1, 89.75);
COMMIT;

INSERT INTO order_details (orders_id, quantity, unit_price)
VALUES (3, 3, 81.67);
COMMIT;

UPDATE order_details
SET quantity = 3, unit_price = 51.92
WHERE orders_id = 1;
COMMIT;

INSERT INTO product (orders_id, code, name, description, unit_weight, fragile, cooled, reference_price)
VALUES (1, 'PROD-001', 'Smartphone Samsung', 'Teléfono inteligente última generación', 0.18, 'S', 'N', 150.50);
COMMIT;

INSERT INTO product (orders_id, code, name, description, unit_weight, fragile, cooled, reference_price)
VALUES (2, 'PROD-002', 'Laptop HP Pavilion', 'Laptop para uso profesional', 2.10, 'S', 'N', 89.75);
COMMIT;

INSERT INTO product (orders_id, code, name, description, unit_weight, reference_price, status)
VALUES (3, 'PROD-003', 'Medicamentos', 'Productos farmacéuticos refrigerados', 0.50, 245.00, 'A');
COMMIT;

UPDATE product
SET cooled = 'S', description = 'Productos farmacéuticos que requieren refrigeración'
WHERE code = 'PROD-003';
COMMIT;

INSERT INTO address (street, "number", district, postal_code, reference, latitude, length, orders_id)
VALUES ('Av. Los Libertadores', '123', 'San Isidro', 15036, 'Frente al parque central', -12.09750000, -77.03640000, 1);
COMMIT;

INSERT INTO address (street, "number", district, postal_code, reference, latitude, length, orders_id)
VALUES ('Jr. Las Flores', '456', 'Miraflores', 15074, 'Edificio azul, tercer piso', -12.11670000, -77.02970000, 2);
COMMIT;

INSERT INTO address (street, "number", district, reference, orders_id)
VALUES ('Calle Los Pinos', '789', 'Surco', 'Casa esquina con portón verde', 3);
COMMIT;

UPDATE address
SET reference = 'Frente al parque central, casa blanca con rejas negras', postal_code = 15037
WHERE orders_id = 1;
COMMIT;

INSERT INTO user_addresses (users_id, address_id, alias, is_main)
VALUES (2, 1, 'Casa Principal', 'S');
COMMIT;

INSERT INTO user_addresses (users_id, address_id, alias, is_main, status)
VALUES (2, 2, 'Oficina', 'N', 'A');
COMMIT;

INSERT INTO user_addresses (users_id, address_id, alias)
VALUES (2, 3, 'Casa Secundaria');
COMMIT;

UPDATE user_addresses
SET alias = 'Oficina Central', is_main = 'N'
WHERE users_id = 2 AND address_id = 2;
COMMIT;

INSERT INTO status_tracking (orders_id, previous_status, new_status, "comment", "user")
VALUES (1, NULL, 'R', 'Pedido recibido correctamente', 'admin@delivery.com');
COMMIT;

INSERT INTO status_tracking (orders_id, previous_status, new_status, "comment", "user")
VALUES (2, 'R', 'C', 'Pedido confirmado y en preparación', 'admin@delivery.com');
COMMIT;

INSERT INTO status_tracking (orders_id, previous_status, new_status, "comment", "user")
VALUES (3, 'C', 'P', 'Preparando productos para envío', 'operador1');
COMMIT;

UPDATE status_tracking
SET "comment" = 'Pedido recibido y validado correctamente por el sistema', "user" = 'sistema_automatico'
WHERE orders_id = 1 AND new_status = 'R';
COMMIT;

INSERT INTO deliveries (orders_id, departure_time, delivery_cost, distance_traveled)
VALUES (1, TIMESTAMP '2025-08-17 09:00:00', 15.00, 12.50);
COMMIT;

INSERT INTO deliveries (orders_id, delivery_cost, distance_traveled, status)
VALUES (2, 12.50, 8.30, 'A');
COMMIT;

INSERT INTO deliveries (orders_id, departure_time, delivery_time, delivery_cost, distance_traveled, status)
VALUES (3, TIMESTAMP '2025-08-17 14:00:00', TIMESTAMP '2025-08-17 15:30:00', 25.00, 18.70, 'E');
COMMIT;

UPDATE deliveries
SET delivery_time = TIMESTAMP '2025-08-17 10:45:00', status = 'E', distance_traveled = 13.20
WHERE orders_id = 1;
COMMIT;

INSERT INTO vehicle (plate, vehicle_type, brand, model, year, load_capacity, last_revision_date, next_review, maturity_insurance, observation)
VALUES ('ABC-123', 'Motocicleta', 'Honda', 'CB150', 2023, 50.00, DATE '2025-06-15', DATE '2025-12-15', DATE '2025-12-31', 'Vehículo en excelente estado');
COMMIT;

INSERT INTO vehicle (plate, vehicle_type, brand, model, year, load_capacity, status)
VALUES ('DEF-456', 'Furgoneta', 'Toyota', 'Hiace', 2022, 1000.00, 'A');
COMMIT;

INSERT INTO vehicle (plate, vehicle_type, brand, model, load_capacity, last_revision_date, observation, status)
VALUES ('GHI-789', 'Camión', 'Isuzu', 'NPR', 2500.00, DATE '2025-07-01', 'Requiere mantenimiento preventivo', 'M');
COMMIT;

UPDATE vehicle
SET status = 'A', observation = 'Mantenimiento completado, vehículo operativo', next_review = DATE '2026-01-01'
WHERE plate = 'GHI-789';
COMMIT;

INSERT INTO vehicle_driver (driver_id, vehicle_id, assignment_date, is_main, observation)
VALUES (3, 1, DATE '2025-01-20', 'S', 'Asignación principal del conductor');
COMMIT;

INSERT INTO vehicle_driver (driver_id, vehicle_id, assignment_date, is_main, status)
VALUES (3, 2, DATE '2025-02-01', 'N', 'A');
COMMIT;

INSERT INTO vehicle_driver (driver_id, vehicle_id, assignment_date, deallocation_date, observation)
VALUES (3, 3, DATE '2025-01-15', DATE '2025-07-01', 'Vehículo enviado a mantenimiento');
COMMIT;

UPDATE vehicle_driver
SET deallocation_date = NULL, status = 'A', observation = 'Reasignado después de mantenimiento'
WHERE driver_id = 3 AND vehicle_id = 3;
COMMIT;

INSERT INTO routes (name, description, main_district, distance_km, estimated_time_minutes, difficulty)
VALUES ('Ruta Centro Lima', 'Ruta principal por el centro histórico de Lima', 'Lima', 15.50, 45, 'medio');
COMMIT;

INSERT INTO routes (name, description, main_district, distance_km, estimated_time_minutes, difficulty, status)
VALUES ('Ruta Miraflores-San Isidro', 'Conexión rápida entre distritos residenciales', 'Miraflores', 8.20, 25, 'facil', 'A');
COMMIT;

INSERT INTO routes (name, description, main_district, distance_km, estimated_time_minutes, difficulty)
VALUES ('Ruta Industrial Callao', 'Ruta hacia zona industrial del Callao', 'Callao', 22.80, 65, 'dificil');
COMMIT;

UPDATE routes
SET estimated_time_minutes = 50, description = 'Ruta principal por el centro histórico, incluye tráfico pesado'
WHERE name = 'Ruta Centro Lima';
COMMIT;

INSERT INTO routes_points (routes_id, "order", name, description, latitude, length, point_type, estimated_time_minutes, distance_meters)
VALUES (1, 1, 'Plaza de Armas', 'Punto de partida centro histórico', -12.04640000, -77.04280000, 'inicio', 0, 0);
COMMIT;

INSERT INTO routes_points (routes_id, "order", name, description, latitude, length, point_type, estimated_time_minutes, distance_meters, observation)
VALUES (1, 2, 'Jr. de la Unión', 'Calle peatonal comercial', -12.04580000, -77.03010000, 'intermedio', 15, 1200, 'Zona de alta congestión peatonal');
COMMIT;

INSERT INTO routes_points (routes_id, "order", name, point_type, estimated_time_minutes, distance_meters)
VALUES (1, 3, 'Estación Central', 'destino', 30, 2500);
COMMIT;

UPDATE routes_points
SET description = 'Calle peatonal comercial - evitar horas pico', estimated_time_minutes = 20
WHERE routes_id = 1 AND "order" = 2;
COMMIT;
